package commands

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/easayliu/alist-aria2-download/internal/api/handlers/telegram/types"
	"github.com/easayliu/alist-aria2-download/internal/application/services"
	"github.com/easayliu/alist-aria2-download/internal/infrastructure/config"
	"github.com/easayliu/alist-aria2-download/pkg/logger"
)

// DownloadCommands ä¸‹è½½ç›¸å…³å‘½ä»¤å¤„ç†å™¨
type DownloadCommands struct {
	downloadService *services.DownloadService
	fileService     *services.FileService
	config          *config.Config
	messageUtils    types.MessageSender
}

// NewDownloadCommands åˆ›å»ºä¸‹è½½å‘½ä»¤å¤„ç†å™¨
func NewDownloadCommands(downloadService *services.DownloadService, fileService *services.FileService, config *config.Config, messageUtils types.MessageSender) *DownloadCommands {
	return &DownloadCommands{
		downloadService: downloadService,
		fileService:     fileService,
		config:          config,
		messageUtils:    messageUtils,
	}
}

// HandleDownload å¤„ç†ä¸‹è½½å‘½ä»¤
func (dc *DownloadCommands) HandleDownload(chatID int64, command string) {
	parts := strings.Fields(command)

	// å¦‚æœæ²¡æœ‰é¢å¤–å‚æ•°ï¼Œé»˜è®¤è¿›å…¥é¢„è§ˆæ¨¡å¼ï¼ˆæœ€è¿‘24å°æ—¶ï¼‰
	if len(parts) == 1 {
		dc.handleManualDownload(chatID, []string{}, true)
		return
	}

	// æ£€æŸ¥ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¦ä¸ºURLï¼ˆä»¥httpå¼€å¤´ï¼‰
	if strings.HasPrefix(parts[1], "http") {
		url := parts[1]

		// åˆ›å»ºä¸‹è½½ä»»åŠ¡
		download, err := dc.downloadService.CreateDownload(url, "", "", nil)
		if err != nil {
			dc.messageUtils.SendMessage(chatID, "åˆ›å»ºä¸‹è½½ä»»åŠ¡å¤±è´¥: "+err.Error())
			return
		}

		// å‘é€ç¡®è®¤æ¶ˆæ¯
		escapedURL := dc.messageUtils.EscapeHTML(url)
		escapedID := dc.messageUtils.EscapeHTML(download.ID)
		escapedFilename := dc.messageUtils.EscapeHTML(download.Filename)
		message := fmt.Sprintf("<b>ä¸‹è½½ä»»åŠ¡å·²åˆ›å»º</b>\\n\\nURL: <code>%s</code>\\nGID: <code>%s</code>\\næ–‡ä»¶å: <code>%s</code>",
			escapedURL, escapedID, escapedFilename)
		dc.messageUtils.SendMessageHTML(chatID, message)
		return
	}

	// æ£€æŸ¥ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¦ä¸ºæ–‡ä»¶è·¯å¾„ï¼ˆä»¥/å¼€å¤´ï¼‰
	if strings.HasPrefix(parts[1], "/") {
		filePath := parts[1]
		
		// åˆ¤æ–­æ˜¯æ–‡ä»¶è¿˜æ˜¯ç›®å½•
		if strings.HasSuffix(filePath, "/") || dc.isDirectoryPath(filePath) {
			// ç›®å½•ä¸‹è½½
			dc.handleDownloadDirectoryByPath(chatID, filePath)
		} else {
			// æ–‡ä»¶ä¸‹è½½
			dc.handleDownloadFileByPath(chatID, filePath)
		}
		return
	}

	// å¤„ç†æ—¶é—´å‚æ•°çš„æ‰‹åŠ¨ä¸‹è½½
	preview := true
	timeArgs := parts[1:]
	if len(timeArgs) > 0 {
		subCommand := strings.ToLower(timeArgs[0])
		switch subCommand {
		case "confirm", "start", "run":
			preview = false
			timeArgs = timeArgs[1:]
		case "preview":
			preview = true
			timeArgs = timeArgs[1:]
		}
	}

	dc.handleManualDownload(chatID, timeArgs, preview)
}

// HandleCancel å¤„ç†å–æ¶ˆä¸‹è½½å‘½ä»¤
func (dc *DownloadCommands) HandleCancel(chatID int64, command string) {
	parts := strings.Fields(command)
	if len(parts) < 2 {
		dc.messageUtils.SendMessage(chatID, "è¯·æä¾›ä¸‹è½½GID\\nç¤ºä¾‹: /cancel abc123")
		return
	}

	gid := parts[1]

	// å–æ¶ˆä¸‹è½½ä»»åŠ¡
	if err := dc.downloadService.CancelDownload(gid); err != nil {
		dc.messageUtils.SendMessage(chatID, "å–æ¶ˆä¸‹è½½å¤±è´¥: "+err.Error())
		return
	}

	escapedID := dc.messageUtils.EscapeHTML(gid)
	message := fmt.Sprintf("<b>ä¸‹è½½å·²å–æ¶ˆ</b>\\n\\nä¸‹è½½GID: <code>%s</code>", escapedID)
	dc.messageUtils.SendMessageHTML(chatID, message)
}

// handleManualDownload å¤„ç†æ‰‹åŠ¨ä¸‹è½½åŠŸèƒ½ï¼ˆä¸´æ—¶å®ç°ï¼‰
func (dc *DownloadCommands) handleManualDownload(chatID int64, timeArgs []string, preview bool) {
	// TODO: å®ç°å®Œæ•´çš„æ‰‹åŠ¨ä¸‹è½½é€»è¾‘
	if preview {
		dc.messageUtils.SendMessage(chatID, "æ‰‹åŠ¨ä¸‹è½½é¢„è§ˆåŠŸèƒ½å¼€å‘ä¸­...")
	} else {
		dc.messageUtils.SendMessage(chatID, "æ‰‹åŠ¨ä¸‹è½½åŠŸèƒ½å¼€å‘ä¸­...")
	}
}

// isDirectoryPath åˆ¤æ–­è·¯å¾„æ˜¯å¦ä¸ºç›®å½•ï¼ˆä¸´æ—¶å®ç°ï¼‰
func (dc *DownloadCommands) isDirectoryPath(path string) bool {
	// å°è¯•è·å–æ–‡ä»¶åˆ—è¡¨æ¥åˆ¤æ–­æ˜¯å¦ä¸ºç›®å½•
	files, err := dc.fileService.ListFilesSimple(path, 1, 1)
	return err == nil && len(files) >= 0
}

// handleDownloadFileByPath é€šè¿‡è·¯å¾„ä¸‹è½½å•ä¸ªæ–‡ä»¶ï¼ˆä¸´æ—¶å®ç°ï¼‰
func (dc *DownloadCommands) handleDownloadFileByPath(chatID int64, filePath string) {
	dc.messageUtils.SendMessage(chatID, "ğŸ“¥ æ­£åœ¨é€šè¿‡/downloadså‘½ä»¤åˆ›å»ºæ–‡ä»¶ä¸‹è½½ä»»åŠ¡...")

	// ä½¿ç”¨æ–‡ä»¶æœåŠ¡è·å–æ–‡ä»¶ä¿¡æ¯
	parentDir := filepath.Dir(filePath)
	fileName := filepath.Base(filePath)
	
	files, err := dc.fileService.ListFilesSimple(parentDir, 1, 1000)
	if err != nil {
		dc.messageUtils.SendMessage(chatID, fmt.Sprintf("âŒ è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %v", err))
		return
	}

	// æŸ¥æ‰¾ç›®æ ‡æ–‡ä»¶
	found := false
	for _, file := range files {
		if file.Name == fileName {
			found = true
			break
		}
	}

	if !found {
		dc.messageUtils.SendMessage(chatID, "âŒ æ–‡ä»¶æœªæ‰¾åˆ°")
		return
	}

	// ä½¿ç”¨æ–‡ä»¶æœåŠ¡çš„æ™ºèƒ½åˆ†ç±»åŠŸèƒ½
	fileInfo, err := dc.fileService.GetFilesFromPath(parentDir, false)
	if err != nil {
		dc.messageUtils.SendMessage(chatID, fmt.Sprintf("âŒ è·å–æ–‡ä»¶è¯¦ç»†ä¿¡æ¯å¤±è´¥: %v", err))
		return
	}

	// æ‰¾åˆ°å¯¹åº”çš„æ–‡ä»¶ä¿¡æ¯
	var targetFileInfo *services.FileInfo
	for _, info := range fileInfo {
		if info.Name == fileName {
			targetFileInfo = &info
			break
		}
	}

	if targetFileInfo == nil {
		dc.messageUtils.SendMessage(chatID, "âŒ è·å–æ–‡ä»¶åˆ†ç±»ä¿¡æ¯å¤±è´¥")
		return
	}

	// åˆ›å»ºä¸‹è½½ä»»åŠ¡
	download, err := dc.downloadService.CreateDownload(targetFileInfo.InternalURL, targetFileInfo.Name, targetFileInfo.DownloadPath, nil)
	if err != nil {
		dc.messageUtils.SendMessage(chatID, fmt.Sprintf("âŒ åˆ›å»ºä¸‹è½½ä»»åŠ¡å¤±è´¥: %v", err))
		return
	}

	// å‘é€æˆåŠŸæ¶ˆæ¯
	message := fmt.Sprintf(
		"âœ… <b>æ–‡ä»¶ä¸‹è½½ä»»åŠ¡å·²åˆ›å»º</b>\\n\\n"+
			"<b>æ–‡ä»¶:</b> <code>%s</code>\\n"+
			"<b>è·¯å¾„:</b> <code>%s</code>\\n"+
			"<b>ä¸‹è½½è·¯å¾„:</b> <code>%s</code>\\n"+
			"<b>ä»»åŠ¡ID:</b> <code>%s</code>\\n"+
			"<b>å¤§å°:</b> %s",
		dc.messageUtils.EscapeHTML(targetFileInfo.Name),
		dc.messageUtils.EscapeHTML(filePath),
		dc.messageUtils.EscapeHTML(targetFileInfo.DownloadPath),
		dc.messageUtils.EscapeHTML(download.ID),
		dc.messageUtils.FormatFileSize(targetFileInfo.Size))

	dc.messageUtils.SendMessageHTML(chatID, message)
}

// handleDownloadDirectoryByPath é€šè¿‡è·¯å¾„ä¸‹è½½ç›®å½•ï¼ˆä¸´æ—¶å®ç°ï¼‰
func (dc *DownloadCommands) handleDownloadDirectoryByPath(chatID int64, dirPath string) {
	dc.messageUtils.SendMessage(chatID, "ğŸ“‚ æ­£åœ¨é€šè¿‡/downloadså‘½ä»¤åˆ›å»ºç›®å½•ä¸‹è½½ä»»åŠ¡...")

	// ä½¿ç”¨æ–‡ä»¶æœåŠ¡è·å–ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶
	files, err := dc.fileService.GetFilesFromPath(dirPath, true)
	if err != nil {
		dc.messageUtils.SendMessage(chatID, fmt.Sprintf("âŒ æ‰«æç›®å½•å¤±è´¥: %v", err))
		return
	}

	if len(files) == 0 {
		dc.messageUtils.SendMessage(chatID, "ğŸ“ ç›®å½•ä¸ºç©ºï¼Œæ²¡æœ‰å¯ä¸‹è½½çš„æ–‡ä»¶")
		return
	}

	// è¿‡æ»¤å‡ºè§†é¢‘æ–‡ä»¶
	var videoFiles []services.FileInfo
	for _, file := range files {
		if dc.fileService.IsVideoFile(file.Name) {
			videoFiles = append(videoFiles, file)
		}
	}

	if len(videoFiles) == 0 {
		dc.messageUtils.SendMessage(chatID, "ğŸ¬ ç›®å½•ä¸­æ²¡æœ‰æ‰¾åˆ°è§†é¢‘æ–‡ä»¶")
		return
	}

	// åˆ›å»ºä¸‹è½½ä»»åŠ¡
	successCount := 0
	failedCount := 0
	var failedFiles []string

	for _, file := range videoFiles {
		download, err := dc.downloadService.CreateDownload(file.InternalURL, file.Name, file.DownloadPath, nil)
		if err != nil {
			failedCount++
			failedFiles = append(failedFiles, file.Name)
			logger.Error("é€šè¿‡/downloadså‘½ä»¤åˆ›å»ºä¸‹è½½ä»»åŠ¡å¤±è´¥", "file", file.Name, "error", err)
			continue
		}
		
		successCount++
		logger.Info("é€šè¿‡/downloadså‘½ä»¤åˆ›å»ºä¸‹è½½ä»»åŠ¡æˆåŠŸ", "file", file.Name, "gid", download.ID)
	}

	// å‘é€ç»“æœæ¶ˆæ¯
	resultMessage := fmt.Sprintf(
		"ğŸ“Š <b>ç›®å½•ä¸‹è½½ä»»åŠ¡åˆ›å»ºå®Œæˆ</b>\\n\\n"+
			"<b>ç›®å½•:</b> <code>%s</code>\\n"+
			"<b>æ‰«ææ–‡ä»¶:</b> %d ä¸ª\\n"+
			"<b>è§†é¢‘æ–‡ä»¶:</b> %d ä¸ª\\n"+
			"<b>æˆåŠŸåˆ›å»º:</b> %d ä¸ªä»»åŠ¡\\n"+
			"<b>å¤±è´¥:</b> %d ä¸ªä»»åŠ¡\\n\\n",
		dc.messageUtils.EscapeHTML(dirPath),
		len(files),
		len(videoFiles),
		successCount,
		failedCount)

	if failedCount > 0 && len(failedFiles) <= 3 {
		resultMessage += "<b>å¤±è´¥çš„æ–‡ä»¶:</b>\\n"
		for _, fileName := range failedFiles {
			resultMessage += fmt.Sprintf("â€¢ <code>%s</code>\\n", dc.messageUtils.EscapeHTML(fileName))
		}
	} else if failedCount > 3 {
		resultMessage += fmt.Sprintf("<b>æœ‰ %d ä¸ªæ–‡ä»¶ä¸‹è½½å¤±è´¥</b>\\n", failedCount)
	}

	if successCount > 0 {
		resultMessage += "\\nâœ… æ‰€æœ‰ä»»åŠ¡å·²ä½¿ç”¨è‡ªåŠ¨è·¯å¾„åˆ†ç±»åŠŸèƒ½\\nğŸ“¥ å¯é€šè¿‡ã€Œä¸‹è½½ç®¡ç†ã€æŸ¥çœ‹ä»»åŠ¡çŠ¶æ€"
	}

	dc.messageUtils.SendMessageHTML(chatID, resultMessage)
}

// HandleYesterdayFiles å¤„ç†è·å–æ˜¨å¤©æ–‡ä»¶ï¼ˆä¸´æ—¶å®ç°ï¼‰
func (dc *DownloadCommands) HandleYesterdayFiles(chatID int64) {
	dc.messageUtils.SendMessage(chatID, "æ­£åœ¨è·å–æ˜¨å¤©çš„æ–‡ä»¶...")

	// ä½¿ç”¨é…ç½®çš„é»˜è®¤è·¯å¾„
	path := dc.config.Alist.DefaultPath
	if path == "" {
		path = "/"
	}

	// è·å–æ˜¨å¤©çš„æ–‡ä»¶
	files, err := dc.fileService.GetYesterdayFiles(path)
	if err != nil {
		dc.messageUtils.SendMessage(chatID, fmt.Sprintf("è·å–æ˜¨å¤©æ–‡ä»¶å¤±è´¥: %v", err))
		return
	}

	if len(files) == 0 {
		dc.messageUtils.SendMessage(chatID, "æ˜¨å¤©æ²¡æœ‰æ–°æ–‡ä»¶")
		return
	}

	// æ„å»ºæ¶ˆæ¯
	message := fmt.Sprintf("<b>æ˜¨å¤©çš„æ–‡ä»¶ (%dä¸ª):</b>\\n\\n", len(files))

	// ç»Ÿè®¡
	var totalSize int64
	tvCount := 0
	movieCount := 0
	otherCount := 0

	for i, file := range files {
		if i < 10 { // åªæ˜¾ç¤ºå‰10ä¸ªæ–‡ä»¶
			sizeStr := dc.messageUtils.FormatFileSize(file.Size)
			message += fmt.Sprintf("[%s] %s (%s)\\n", file.MediaType, dc.messageUtils.EscapeHTML(file.Name), sizeStr)
		}

		totalSize += file.Size
		switch file.MediaType {
		case "tv":
			tvCount++
		case "movie":
			movieCount++
		default:
			otherCount++
		}
	}

	if len(files) > 10 {
		message += fmt.Sprintf("\\n... è¿˜æœ‰ %d ä¸ªæ–‡ä»¶æœªæ˜¾ç¤º\\n", len(files)-10)
	}

	// æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
	message += fmt.Sprintf("\\n<b>ç»Ÿè®¡ä¿¡æ¯:</b>\\n")
	message += fmt.Sprintf("æ€»å¤§å°: %s\\n", dc.messageUtils.FormatFileSize(totalSize))
	if tvCount > 0 {
		message += fmt.Sprintf("ç”µè§†å‰§: %d\\n", tvCount)
	}
	if movieCount > 0 {
		message += fmt.Sprintf("ç”µå½±: %d\\n", movieCount)
	}
	if otherCount > 0 {
		message += fmt.Sprintf("å…¶ä»–: %d\\n", otherCount)
	}

	dc.messageUtils.SendMessageHTML(chatID, message)
}

// HandleYesterdayDownload å¤„ç†ä¸‹è½½æ˜¨å¤©çš„æ–‡ä»¶ï¼ˆä¸´æ—¶å®ç°ï¼‰
func (dc *DownloadCommands) HandleYesterdayDownload(chatID int64) {
	dc.messageUtils.SendMessage(chatID, "æ­£åœ¨å‡†å¤‡ä¸‹è½½æ˜¨å¤©çš„æ–‡ä»¶...")

	// ä½¿ç”¨é…ç½®çš„é»˜è®¤è·¯å¾„
	path := dc.config.Alist.DefaultPath
	if path == "" {
		path = "/"
	}

	// è·å–æ˜¨å¤©çš„æ–‡ä»¶
	files, err := dc.fileService.GetYesterdayFiles(path)
	if err != nil {
		dc.messageUtils.SendMessage(chatID, fmt.Sprintf("è·å–æ˜¨å¤©æ–‡ä»¶å¤±è´¥: %v", err))
		return
	}

	if len(files) == 0 {
		dc.messageUtils.SendMessage(chatID, "æ˜¨å¤©æ²¡æœ‰æ–°æ–‡ä»¶éœ€è¦ä¸‹è½½")
		return
	}

	// æ‰¹é‡æ·»åŠ ä¸‹è½½ä»»åŠ¡
	successCount := 0
	failCount := 0

	for _, file := range files {
		// åˆ›å»ºä¸‹è½½ä»»åŠ¡
		_, err := dc.downloadService.CreateDownload(
			file.InternalURL,
			file.Name,
			file.DownloadPath,
			nil, // ä½¿ç”¨é»˜è®¤é€‰é¡¹
		)
		if err != nil {
			failCount++
		} else {
			successCount++
		}
	}

	// å‘é€ç»“æœ
	message := fmt.Sprintf("<b>ä¸‹è½½ä»»åŠ¡åˆ›å»ºå®Œæˆ</b>\\n\\n")
	message += fmt.Sprintf("æˆåŠŸ: %d\\n", successCount)
	if failCount > 0 {
		message += fmt.Sprintf("å¤±è´¥: %d\\n", failCount)
	}
	message += fmt.Sprintf("æ€»è®¡: %d\\n", len(files))

	dc.messageUtils.SendMessageHTML(chatID, message)
}